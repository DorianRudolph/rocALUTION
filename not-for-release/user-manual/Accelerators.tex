\chapter{Backends}

The support of accelerator devices is embedded in the structure of PARALUTION. The primary goal is to use this technology whenever possible to decrease the computational time. 

\textbf{\emph{Note}} Not all functions are ported and presented on the accelerator backend. This limited functionality is natural since not all operations can be performed efficiently on the accelerators (e.g. sequential algorithms, I/O from the file system, etc).


\section{Backend and Accelerators}

Currently, the library supports CUDA GPU \cite{cuda}, OpenCL \cite{opencl} and MIC \cite{mic} devices. Due to its design the library can be extended to support Cilk \cite{cilk}, Intel TBB \cite{tbb} backends. The extension of the library will not reflect the algorithms which are based on it.

If a particular function is not implemented for the used accelerator, the library will move the object to the host and compute the routine there. In this a case warning message of level 2 will be printed. For example if we use an OpenCL backend and we want to perform an ILU($0$) factorization which is currently not available, the library will move the object to the host, perform the routine there and print the following warning message:

\lstinputlisting[title="Warning message for performing the ILU($0$) factorization on the host"]{./src/no_fct_accel.txt}


\section{Copy}

All matrices and vectors have a \emph{CopyFrom()} function which can be used to transfer data from and to the accelerator.

\lstinputlisting[title="Copying data to and from the accelerator"]{./src/cp_acc.cpp}

\section{CloneBackend}

When creating new objects, often the user has to ensure that it is allocated on the same backend as already existing objects. This can be achieved via the \emph{CloneBackend} function. For example, consider a matrix \emph{mat} and a vector \emph{vec}. If a SpMV operation should be performed, both objects need to be on the same backend. This can be achieved by calling \emph{vec.CloneBackend(mat)}. In this way, the vector will have the same backend as the matrix. Analoguely, \emph{mat.CloneBackend(vec)} can be called. Then, the matrix will end up with the same backend as the vector.

\section{Moving Objects To and From the Accelerator}

All object in PARALUTION can be moved to the accelerator and to the host.

\lstinputlisting[title="Using an accelerator for sparse matrix-vector multiplication"]{./src/accel_host.cpp}

\lstinputlisting[title="Using an accelerator for preconditioned CG solver (building phase on the host)"]{./src/accel_pcg1.cpp}

\lstinputlisting[title="Using an accelerator for preconditioned CG solver (building phase on the accelerator)"]{./src/accel_pcg2.cpp}

\section{Asynchronous Transfers}

The PARALUTION library also provides asynchronous transfers of data (currently, only for CUDA backend). This can be done with the \emph{CopyFromAsync()} function or with the \emph{MoveToAcceleratorAsync()} and \emph{MoveToHostAsync()}. These functions return immediately and perform the asynchronous transfer in background mode. The synchronization is done with the \emph{Sync()} function.

\lstinputlisting[title="Asynchronous Transfers with \emph{MoveToAcceleratorAsync}"]{./src/async1.cpp}

\lstinputlisting[title="Asynchronous Transfers with \emph{CopyFromAsync}"]{./src/async2.cpp}

When using the \emph{MoveToAcceleratorAsync()} and \emph{MoveToHostAsync()} functions, the object will still point to its original location (i.e. host for calling \emph{MoveToAcceleratorAsync()} and accelerator for \emph{MoveToHostAsync()}). The object will switch to the new location after the \emph{Sync()} function is called.

\lstinputlisting[title="Asynchronous Transfers with \emph{MoveToAcceleratorAsync()}"]{./src/async3.cpp}

\textbf{\emph{Note}} The objects should not be modified during an active asynchronous transfer. However, if this happen, the values after the synchronization might be wrong.

\textbf{\emph{Note}} CUDA backend -- to use the asynchronous transfers you need to enable the pinned memory allocation. Uncomment \emph{\#define PARALUTION\_CUDA\_PINNED\_MEMORY} in file \emph{src/utils/allocate\_free.hpp}

\section{Systems without Accelerators}

PARALUTION provides full code compatibility on systems without accelerators - i.e. the user can take the code from the GPU systems, re-compile the same code on a machine without a GPU and it will provide the same results. For example, if one compiles the above matrix-vector multiplication code on a system without GPU support, it will just perform two multiplications on the host - the \emph{MoveToAccelerator()} and \emph{MoveFromAccelerator()} calls will be ignored.

